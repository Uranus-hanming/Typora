[toc]

###### 1. 什么是python？

   > python是一种免费、开源、跨平台、解释型、面向对象、动态数据类型的高级程序设计语言。

   - 动态类型语言：在声明变量时，不需要指定变量的类型
   - 代码从上到下执行
   - 对缩进敏感

###### 2. python2 和 python3的区别

   - print
   - 2使用ASCII编码，3使用UTF-8编码，支持中文
   - 不等式：!=  <>
   - map/filter/reduce从返回列表变为生成器

###### 3. 运算符

   1. 算术运算符
   2. 赋值运算符
   3. 比较运算符
   4. 逻辑运算符：and  or  not
   5. 位运算符：& |
   6. 成员运算符：in    not in
   7. 身份运算符：is     is not   x is y 类似于 id(x) ==  id(y)

###### 4. 可变的数据类型和不可变的数据类型，使用id()方法判断

   > 元祖嵌套列表，更改了列表的内容，虽然元祖中嵌套的列表的值改变了，但是因为列表是可变的数据类型，列表的值改变了，内存地址（id值）并没有改变，所以元祖的内存地址也没有改变，可以用id()来检验，元祖依然被认为是不可变的数据类型。
   >
   > 字典的key只能用不可变的数据类型
   >
   > 元祖：(1,) 逗号不能省

   - 不可变的数据类型

     > 不可变数据类型在第一次声明赋值声明的时候, 会**在内存中开辟一块空间**, 用来存放这个变量被赋的值, 而这个变量实际上存储的, 并不是被赋予的这个值, 而是**存放这个值所在空间的内存地址**, 通过这个地址, 变量就可以在内存中取出数据了. 所谓不可变就是说, **我们不能改变这个数据在内存中的值**, 所以当我们改变这个变量的赋值时, 只是在内存中重新开辟了一块空间, 将这一条新的数据存放在这一个新的内存地址里, 而原来的那个变量就不在引用原数据的内存地址而转为引用新数据的内存地址了

   - 可变的数据类型

     > 可变类型的变量在第一次赋值声明的时候，也会在内存中开辟一块空间，用来存储这个变量被赋予的值。我们**能修改存储在内存中的值**，当该变量的值发生了改变，它对应的内存地址不发生改变。
     >
     > **可变数据类型变量中的值变化，地址不会变。**若对变量进行重新赋值，则变量的地址也会改变。

###### 5. python变量为什么不需要声明？

   > a存放的是地址：id(a)
   >
   > 这个也与python中a代表地址有关，其它语言中把值赋给a的同时也限制了a的类型，其它语言中a代表的就是一个实实在在的量，而python中a代表的是**指向这个量的地址**，**这个地址可以指向任何类型数据的存储空间**，指向整型，a就是整型，指向字符串，a就是字符串，指向函数对象，a就是函数对象，这就是python中的隐式声明。

###### 6. 变量怎么回收？

   > Python中的del是将这个对象的指向删除，当这个对象没有任何指向的时候，Python虚拟机才会删除这个对象。
   >
   > 对象引用计数；分代垃圾回收

###### 7. 序列
   1. 字符串、列表、字典、元祖、集合、二进制序列、range

   2. 容器序列：列表、字典、元祖、集合

      > 可以容纳不同类型的元素；
      >
      > 存放的只是相应**对象的引用**，而对象的引用可以是任意类型。

   3. 扁平序列：字符串类型、二进制序列、range

      > 只能容纳一个类型的元素；
      >
      > 在内存中存放的是真实的值，即存放原始数据类型，如字符、字节和树

   4. 可变的序列：列表、字典、集合

   5. 不可变的序列：字符串、元祖、二进制

   6. 数据类型转换函数

      | 函数                 | 描述                                                 |
      | -------------------- | ---------------------------------------------------- |
      | int(x)               | 将x转换为一个整数                                    |
      | float(x)             | 将x转换到一个浮点数                                  |
      | complex(real[,imag]) | 创建一个复数                                         |
      | str(x)               | 将对象x转换成字符串                                  |
      | repr(x)              | 将对象x转换为表达式字符串                            |
      | eval(x)              | 用来计算在字符串中的有效python表达式，并返回一个对象 |
      | tuple(s)             | 将序列s转换为一个元祖                                |
      | list(s)              | 将序列s转换为一个列表                                |
      | set(s)               | 转换为可变集合                                       |
      | dict(d)              | 创建一个字典，d必须是一个序列(key, value)元祖        |
      | frozenset(s)         | 转换为不可变集合                                     |
      | chr(x)               | 将一个整数转换为一个字符                             |
      | ord(x)               | 将一个字符转换为它的整数值                           |
      | hex(x)               | 将一个整数转换为一个十六进制字符串                   |
      | oct(x)               | 将一个整数转换为一个八进制字符串                     |

###### 8. 元素去重并按原来的顺序排列

   ```python
   elements = ['a', 'a', 'c', 'c', 'b', 'b']
   e = list(set(elements))
   e.sort(key=elements.index)
   ```

###### 9. 时间模块：time、datetime、calendar

###### 10. 异常：try、except、raise

| 名称             | 含义                             |
| ---------------- | -------------------------------- |
| IOError          | 输入输出错误                     |
| AttributeError   | 试图访问一个对象没有的属性       |
| ImportError      | 无法导入模块或包，基本是路径问题 |
| IndentationError | 语法错误，代码没有正确的对齐     |
| IndexError       | 下标索引超出序列边界             |
| KeyError         | 视图访问字典里不存在的键         |
| SyntaxError      | python代码逻辑语法出错，不能执行 |
| NameError        | 使用一个还未赋予对象的变量       |

###### 11. 将标准输出（1>、1>>）和标准错误输出（2>、2>>）同时重定向到同一位置：2>&1

###### 12. 名称前的单下划线（如：_name）

   > 用于指定属性和方法是“私有”的，只是代表该属性、方法或类只能在内部使用，是API中非公开的部分。
   >
   > 用`from <moule> import *` 无法导入
   >
   > 可以将私有属性、方法或类加入\_\_all\_\_列表中进行导入

###### 13. 名称前的双下划线（如：__name）

   > 如何调用双下划线开头的方法和属性？
   >
   > 要以“_类__方法（属性）”的形式来对方法或属性的访问。
   >
   > 目的是为了避免父类的方法被子类轻易覆盖

###### 14. python的函数参数传递方式是什么？

   - 值传递：

      > 指的是在调用函数时，将**实际参数**复制一份传递给形式参数，这样在函数中就可以修改**形式参数**，而不会影响到实际参数。
      >
      > 对于**不可变类型（数值型、字符串、元祖）**，因为变量不能被修改，所以运算不会影响到变量自身

   - 引用传递：

      > 在调用函数时，将**实际参数的地址**传递给函数，这样在函数中对参数的修改会直接影响到实际参数。
      >
      > 对于**可变类型（列表、字典）**来说，函数内部的运算可能会更改传入的参数变量。

###### 15. 闭包

   > **内部函数**可以引用**外部函数**的**参数和局部变量**，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中。
   >
   > 闭包是两个函数的嵌套，外部函数返回内部函数的引用，外部函数一定要有参数。

###### 16. *args和\*\*kwargs的作用：

   > *args 和 **kwargs主要用于函数的定义。当函数的参数不确定时，可以使用\* args和 \*\*kwargs来将不定数量的参数传递给一个函数。
   >
   > *args 和 **kwargs作为函数的参数时，作用的效果是和 ；
   >
   > *args 和 **kwargs作为函数的调用时，作用的效果是分；

   - 包含*args和**kwargs

   ```python
      # 自定义函数，包含*args和**kwargs
      def func(argument, *args, **kwargs):
          print('argument = ', argument)
          print('args类型：', type(args))
          print('args = ',args)
          print('kwargs类型：', type(kwargs))
          print('kwargs = ',kwargs)
       
      # 调用函数，方法1
      func(1, 2, 3, 4, a=1, b=2)
       
      # 调用函数，方法2
      tuple = (1, 2, 3, 4)
      dict = {'a': 1, 'b': 2}
      func(*tuple, **dict)  # 注意这里会把tuple解包出来的第一个实参1传给形参argument
       
      ---------------------------------------------------------------------------------
      运行结果：
      argument =  1
      args类型： <class 'tuple'>
      args =  (2, 3, 4)
      kwargs类型： <class 'dict'>
      kwargs =  {'a': 1, 'b': 2}
      argument =  1
      args类型： <class 'tuple'>
      args =  (2, 3, 4)
      kwargs类型： <class 'dict'>
      kwargs =  {'a': 1, 'b': 2}
   ```


   - *args是用来发送一个**非键值对的可变数量**的参数给一个函数。\*args会接收任意多个参数并把这些参数作为元祖传递给函数。\*args没有key值，以**元祖形式**传递。

      ```python
      # 自定义函数，只有*args
      def func(*args):
          """
          *参数收集所有未匹配的位置参数组成一个tuple对象，局部变量args指向此tuple对象
          """
          print('args类型：', type(args))
          print('args=', args)
       
       
      # 调用函数，方法1
      func(1, 2, 3, 4)
       
      # 调用函数，方法2，解包
      tuple = (1, 2, 3, 4)
      func(*tuple)    # *参数用于解包tuple对象的每个元素，作为一个一个的位置参数传入到函数中
       
      -----------------------------------------------------------------------
      运行结果：
      args类型： <class 'tuple'>
      args= (1, 2, 3, 4)
      args类型： <class 'tuple'>
      args= (1, 2, 3, 4)
      ```


   - \*\*kwargs存储**可变的关键字参数**，允许使用没有事先定义的参数名，将接收到任意多个关键字参数作为字典传递给函数。\*\*kwargs有key值，以**字典形式**传递。

      ```python
      # 自定义函数，只有**kwargs
      def func(**kwargs):
          """
          **参数收集所有未匹配的关键字参数组成一个dict对象，局部变量kwargs指向此dict对象
          """
          print('kwargs类型：', type(kwargs))
          print('kwargs = ', kwargs)
       
      # 调用函数，方法1
      func(a=1, b=2)
       
      # 调用函数，方法2，解包
      dict = {'a': 1, 'b': 2}
      func(**dict) # **参数用于解包dict对象的每个元素，作为一个一个的关键字参数传入到函数中
       
      -----------------------------------------------------------------------
      运行结果：
      kwargs类型： <class 'dict'>
      kwargs =  {'a': 1, 'b': 2}
      kwargs类型： <class 'dict'>
      kwargs =  {'a': 1, 'b': 2}
      ```

###### 17. os 和 sys 模块的区别？

   > os 模块是负责程序与**操作系统**的交互，提供了访问操作系统底层的接口；
   >
   > sys模块是负责程序与**python解释器**的交互，提供了一系列的函数和变量，用于操控python运行时的环境。

###### 18. help()和dir()函数的作用

    1. help()函数是一个内置函数，用于查看**函数或模块**用途的详细说明。
    2. dir()函数是Python内置函数，不带参数时返回当前范围内的**变量、方法和定义的类型**列表；带参数时，返回**参数的属性、方法**列表。

###### 19. 生成器：一边循环一边计算的机制

   > yield的作用：yield可以**保存当前运行的状态**（断点），然后暂停执行，即将函数挂起。将yield关键字后面表达式的值作为返回值返回，如果使用**next()、send()函数**让函数从断点处继续执行，就会唤醒函数。

###### 20. 检验类型的函数：isinstance() 和 type()

   - isinstance()能够判断出子类的实例化对象属于父类，**考虑继承关系**
   - type()不会认为子类是一种父类类型，不考虑继承关系

###### 21. 赋值"="：

   > 使用“=”可以对一个变量进行赋值，赋值就是**创建了对象的一个新的引用**。赋值并不会产生一个独立的对象，它只是将原来的数据对象**添加一个新标签**，所以，当其中一个标签被改变时，数据对象就会发生变化，另一个标签也会随之改变。Python中对象的赋值都是进行**对象引用（内存地址）传递**。

###### 22. 浅拷贝：copy.copy()

   > **浅拷贝只拷贝对象本身，不会拷贝其内部的嵌套对象。**对于内部的嵌套对象，依然使用原始的引用。

   - 当浅拷贝的值是**不可变对象**（数值、字符串、元祖）时和“赋值”的情况一样，对象的id值与浅拷贝原来的值相同。
   - 当浅拷贝的值是**可变对象**（列表、集合、字典）时会产生一个“不是那么独立的对象”存在：
      - 第一种情况：赋值的对象中无嵌套复杂对象，原来值的改变并不会影响浅拷贝的值，同时浅拷贝的值改变也不会影响原来的值。原来值的id值与浅拷贝原来的值不同
      - 第二种情况：复制的对象中有嵌套复杂对象，如果不改变其中嵌套的复杂对象，那么浅拷贝的值改变并不会影响原来的值，但是改变原来的值中的复杂子对象的值会影响浅拷贝的值。因为复杂子对象的保存方式是作为引用方式存储的，所以修改浅拷贝的值和原来的值都可以改变复杂子对象的值。
```python
l = [[]] * 5

print(l)
# [[], [], [], [], []] 创建了五个列表，但都是对同一个列表的引用

l[0].append(10)
print(l)
# [[10], [10], [10], [10], [10]]

l[1].append(20)
print(l)
# [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]

l.append(30)
print(l)
# [[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
```

###### 23. 深拷贝：copy.deepcopy()

   > 深拷贝会拷贝对象本身及其所有的嵌套对象。

###### 24. python的内存管理

   - 引用计数
   - 分代垃圾回收机制

###### 25. 高阶函数

   - map(function, iterable,...)

      > 根据提供的函数对指定序列做映射。

      ```python
      list(lambda x:x**2, [1, 2, 3, 4, 5])
      ```

   - reduce(function, utterable[, initializer])

      > initializer -- 初始参数
      >
      > reduce()函数会对参数序列中过元素进行累积。
      >
      > reduce()函数将一个数据集合中的所有数据进行下列操作：用传给reduce中的函数function（有两个参数）先对集合中的第1、2个元素进行操作，得到的结果再与第三个数据用function函数运算，最后返回函数计算结果。

      ```python
      from functools import reduce

      def add(x, y):
        return x + y

      result = reduce(add, [1, 2, 3])
      ```

   - filter(function, iterable)

      > 用于过滤序列，把传入的函数依次作用于序列中的每个元素，然后根据函数返回值（True、False）决定是否保留该元素。

      ```python
      filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5])
      ```

   - enumerate(sequence, [start=0])

      > 用于将一个可遍历的数据对象（如列表、元祖或字符串）组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中得到计数。

   - zip(iterable1, iterable2, ...)

      > 该函数在运算时，会以一个或多个序列（可迭代对象）作为参数，返回一个元祖的列表，同时将这些序列中并排的元素配对。

###### 26. \_\_init\_\_方法的作用：构造方法

   > 类的实例化操作会自动调用这个方法。这个**初始化方法**，会在对象创建后，而且在返回给调用者之前自动调用。该方法中只能返回None，不能返回其他任何类型。

###### 27. \_\_new\_\_和 \_\_init\_\_的区别？

###### 28. \_\_repr\_\_和\_\_str\_\_的区别？

   > 两个方法都是用于显示输出结果，\_\_str\_\_是面向用户的，\_\_repr\_\_是面向程序员的。
   >
   > 当调用print函数时，对应调用的是\_\_str\_\_；当直接在终端输出对象时，调用的是\_\_repr\_\_函数。

###### 29. 被@classmethod修饰的方法叫作**类方法**，也叫类函数。类方法可以通过**类名调用**，也可以通过对象名调用，但是一般都通过类名调用。类方法必须有一个参数cls，即当前类。

###### 30. 被@staticmethod修饰的方法叫作**静态方法**，也叫静态函数。静态方法可以通过**类名调用**，也可以通过对象名调用，但是一般都通过类名调用。

###### 31. **对象方法/成员方法**：类里面定义的普通方法称之为**实例方法**，实例方法通过**对象名调用**。实例方法必须有一个参数，一般这个参数被命名为self。

###### 32. 私有属性：

   > 以\_\_开头的成员属性为类的私有属性，私有属性在类的外部不能直接访问（但可以通过\_类名\_\_属性名来访问），但是在类里面可以直接访问
   >
   > 通过官方装饰器：@property和@方法名.setter

###### 33. 特性：@property和@方法名.setter

   ```python
    class C:
        def __init__(self):
            self.score = 85
     
        def get_score(self):
            if self.score < 60:
                return "你妹的，不及格！"
            else:
                return self.score
     
        def set_score(self, value):
            if 0 <= value <= 100:
                self.score = value
            else:
                print(f"输入的值 {value} 超出范围 0~100 ！")
     
        def del_score(self):
            del self.score
            print("完成 score 属性的删除！")
     
        score_x = property(fget=get_score, fset=set_score, fdel=del_score, doc="score_x 是 score 的托管属性。")
     
     
    c = C()
    c.score_x = 45          # 直接使用实例对象调用 score_x 进行赋值，背后还是调用了方法实现了过滤
    print(c.score_x)        # 获取 score_x 的值
    del c.score_x           # 删除 score

    -------------------------------------------------------------

    class C:
        def __init__(self):
            self.score = 85
     
        @property                           # @property 装饰器本身就相当于 getter 方法
        def score_x(self):
            if self.score < 60:
                return "你妹的，不及格！"
            else:
                return self.score
     
        @score_x.setter                     # 给 score_x 属性装饰 setter 方法
        def score_x(self, value):           # 附加方法与原始的特征属性相同的名称
            if 0 <= value <= 100:
                self.score = value
            else:
                print(f"输入的值 {value} 超出范围 0~100 ！")
     
        @score_x.deleter                    # 给 score_x 属性装饰 deleter 方法
        def score_x(self):                  # 附加方法与原始的特征属性相同的名称
            del self.score
     
     
    c = C()
    print(c.score_x)
    c.score_x = 45
    print(c.score_x)
   ```

###### 34. 私有方法：

   > 在成员方法前面加上\_\_，在类的外部不能直接访问（可以通过\_类名\_\_方法名来访问），在类的内部可以直接访问。

###### 35. 系统编程

   - 对于操作系统来说，一个任务就是一个进程（process）。一个运行的程序（代码）就是一个进程，没有运行的代码叫程序。**进程是系统进行资源分配和调度的一个独立单位**，进程拥有自己独立的内存空间，所以进程间数据不共享，创建和销毁进程的开销比较大。
   - 在一个进程内部，要同时做多件事，就需要同时运行多个“子任务”，把进程内的这些“子任务”称为线程（Thread）。**线程是调度执行的最小单位，也叫执行路径，不能独立存在，必须依赖于进程存在**。一个进程至少有一个线程，叫**主线程**，而多个线程共享内存（数据共享，共享全局变量），从而极大地提高了程序的运行效率。
   - 一个进程至少有一个线程。多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。
        - 协程是一种**用户态的轻量级线程**，协程的调度完全由用户控制。**协程拥有自己的寄存器上下文和栈**。协程调度切换时，会将寄存器上下文和栈保存到其他地方，在切回的时候，恢复先前保存的寄存器上下文和栈，这样通过直接操作栈的方式做切换基本没有内核切换的开销，**可以不加锁的访问全局变量**，所以上下文的切换非常快。

###### 36. mysql基本操作

    1. insert into
    
    2. update table set
    
    3. delete from table
    
    4. 模糊查询like
    
       > like用于在where子句中进行模糊查询，使用百分号%来表示任意0个或多个字符，下划线_表示任意一个字符。
    
    5. as用于给字段或表重命名
    
    6. 联合查询：UNION [all]
    
       > UNION操作符用于连接两个以上的SELECT语句的结果组合到一个结果集中。
       >
       > all 为可选：有，返回所有结果集，包含重复数据；没有，则去重
    
    7. 排序：order by [desc]
    
    8. 分页：limit
    
    9. 聚合查询：group by （聚合运算：+-*/%）
    
    10. 聚合筛选：having
    
    11. 去重语句：distinct

###### 37. 事务

   - 4个特性

      1. 原子性

      2. 一致性

      3. 隔离性（对于并发事务而言的）

         > 不可重复读：是由于事务并发修改同一条记录导致的，要避免这种情况可以对要修改的记录加锁，但会影响数据库性能。
         >
         > 幻读：是由于并发事务增加记录导致的，可以将**事务串行化**来避免幻读。
         >
         > 脏读：是某一事务读取了另一个事务未提交的脏数据
         >
         > 隔离级别越低，并发性能越高

         1. 未提交读：读取未提交的内容

         2. 提交读：读取提交内容

         3. 可重复读：解决了脏读的问题，但解决不了幻读的问题；MySQL数据库的默认隔离级别

         4. 可串行化：

            > 通过强制事务排序，强制事务串行执行，使之不可能相互冲突，从而解决幻读问题

      4. 持久性（数据更新的结果从内存保存到外部存储器）

###### 38. 设计关系型数据库的范式

   > 主要目的是消除重复数据，减少数据冗余；越高的范式数据库冗余越小。
   >
   > 范式的优点：让数据库内的数据更好地组织，让磁盘空间得到更有效地利用。
   >
   > 缺点：范式使查询变得复杂。
   >
   > 关系型数据库有六种范式；
   >
   > 满足高等级的范式的先决条件是必须先满足低等级范式。

###### 39. 存储过程

   > 是用户定义的**一系列SQL语句的集合**，是存储在数据库中的程序，用户可以调用存储过程；
   >
   > 存储过程用于执行特定的操作，可以接受输入参数、输出参数、返回单个或多个结果集。

   - 增强SQL语言的功能和灵活性
   - 保证数据的安全性
   - 维护数据库的完整性
   - 特高数据库的执行效率
   - 降低网路流量

###### 40. 存储过程和函数的区别：

    1. 标识符不同：FUNCTION/PROCEDURE
    2. 函数必须有返回值，且只能返回一个值；存储过程可以有多个返回值
    3. 函数可以在SELECT语句中直接使用，而存储过程不能

###### 41. 触发器

   > 触发器与存储过程的区别：存储过程是由用户或程序**显式调用**的；触发器是不能被直接调用的，而是由一个事件来触发运行，即触发器是当某个事件发生时自动地**隐式运行**。

   - 可维护数据库的安全性、一致性和完整性

###### 42. 视图

   > 是从数据库的基表中选取出来的数据组成的逻辑窗口，是一个虚拟表。
   >
   > 在数据库中，存放的只是视图的定义，而不存放数据，这些数据仍然存放在原来的基本表结构中。只有在使用视图的时候，才会执行视图的定义，从基本表中查询数据。
   >
   > 优点：对数据的一种重构，不影响原数据表的使用，提高安全性，可以给不同用户提供不同的视图
   >
   > 缺点：性能较差，有时需要处理表依赖关系
   >
   > CREATE VIEW view_name AS [select_statement]

###### 43. 索引操作

   > 索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。
   >
   > 优点：结块数据检索，提高查找效率。
   >
   > 缺点：占用存储空间，更新数据时索引需动态维护，降低数据写入效率。

    1. 索引分类
       1. 普通索引
       2. 唯一索引
       3. 主键索引
    2. 创建索引：create [unique] index 索引名 on 表名/字段名;
    3. 查看索引：show index from 表名;
    4. 删除索引：drop index 索引名 on 表名;

###### 44. 外键约束：foreign[ˈfɔːrən] key

    1. 一对一
    2. 一对多
    3. 多对多

###### 45. 表关联查询

    1. 内连接
    
       > 内连接查询只会查找到符合条件的记录，其实结果和表关联查询是一样的
    
    2. 外连接
    
       1. 左连接：以左表为主表，显示右表中与左表匹配的项，没有匹配的项为null
       2. 右连接：以右表为主表，显示左表中与右表匹配的项，没有匹配的项为null
    
    3. 

###### 46. redis

   > 免费开源，key-value数据库

    1. 优点：内存存储、持久化，运行速度快，可用于高速缓存
    2. 应用实例：celery的异步任务和定时任务
    3. 数据类型
       1. 字符串string
       2. 哈希hash
       3. 列表list
       4. 集合set
       5. 有序集合sorted set

###### 47. celery（异步任务，定时任务）

   > Celery是Python开发的简单、灵活可靠的、处理大量消息的**分布式任务调度模块**
   >
   > 专注于实时处理的异步任务队列和定时任务

    1. 消息中间件broker（redis提供任务队列）
    2. 任务执行单元worker
    3. 任务结果存储backend（结果存储于redis）
    4. 异步任务
       1. init.py
       2. celeryconfig.py
       3. task.py
       4. client.py
       5. 最后启动worker进程
    5. 定时任务
       1. celeryconfig.py
       2. task.py
       3. 最后启动worker进程，再启动beat进程（beat进程通过读取配置文件的内容，周期性地将定时任务发往任务队列）

###### 48. Python常用标准库

    1. re正则表达式
    2. 日期日历和时间模块：time/datetime/calendar
    3. 容器数据类型：collections
    4. 函数式变成模块：functools/itertools/operator
    5. heapq堆队列算法
    6. queue队列
    7. math 数学函数
    8. random
    9. os/sys：跟操作系统和Python解释器交互
    10. 并发：threading/multiprocessing

###### 49. python常用第三方库

    1. 数据分析和可视化：pandas/numpy/scipy
    2. 网络爬虫：requests/scrapy
    3. 自动化：selenium/pymysql/openpyxl
    4. web开发：flask/django

###### 50. RESTful（令人舒适的）的特征

    1. 每一个URL代表一种资源
    2. 客户端和服务器端之间传递着资源的某种表现
    3. 客户端通过HTTP的几个动作（GET/POST/PUT/DELETE/OPTIONS/HEAD/CONNECT/TRACE）对资源进行操作

###### 51. 如何设计复合RESTful特征的API

    1. 协议使用http/https
    
    2. 域名：域名中体现出api字样
    
    3. 体现版本
    
    4. 路径中的资源使用名词表示
    
    5. 选择合适的http访问方式
    
    6. 巧用查询字符串
    
    7. http响应码和自定义内部code进行响应
    
       ```
       200 OK - [GET]：服务器成功返回用户请求的数据
       201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
       202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
       204 NO CONTENT - [DELETE]：用户删除数据成功。
       400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
       401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
       403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
       404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
       406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
       410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
       422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
       500 INTERNAL SERVER ERROR - [*]：服务器发生错误
       ```
    
    8. 根据HTTP动作的不同，返回结果的结构也不同
    
       ```
       GET /users：返回资源对象的列表（数组）
       GET /users/guoxiaonao：返回单个资源对象
       POST /users：返回新生成的资源对象
       PUT /users/guoxiaonao：返回完整的资源对象
       PATCH /users/guoxiaonao：返回完整的资源对象
       DELETE /users/guoxiaonao：返回一个空文档
       ```

###### 52. http访问的方式

   - GET/POST/PUT/DELETE/OPTIONS/HEAD/CONNECT/TRACE
   - get取，是查询数据，对应select操作；从服务器取出资源
   - post贴，常用于新增数据，对应insert操作；在服务器新建一个资源
   - put放，常用于修改数据，对应update操作；在服务器更新资源
   - delete删，是删除数据，对用delete操作；从服务器删除资源

###### 53. 字节串

    > 在python3中引入了字节串的概念，与str不同，**字节串**以**字节序列值**表达数据，更方便用来处理二进程数据。
    
    - 普通的ascii编码字符串可以在前面加b转换为字节串，例如：b’hello’
    - 字符串转换为字节串方法 ：str.encode()
    - 字节串转换为字符串方法 : bytes.decode()

###### 54. OSI七层模型

   > 使网络通信工作流程标准化

    1. 应用层 ： 提供用户服务，具体功能有应用程序实现
    2. 表示层 ： 数据的压缩优化加密
    3. 会话层 ： 建立用户级的连接，选择适当的传输服务
    4. 传输层 ： 提供传输服务
    5. 网络层 ： 路由选择，网络互联
    6. 链路层 ： 进行数据交换，控制具体数据的发送
    7. 物理层 ： 提供数据传输的硬件保证，网卡接口，传输介质

###### 55. 四层模型（TCP/IP模型）

   > TCP: 面向连接，提供可靠的数据传输
   >
   > UDP: 面向无连接，不可靠传输，适用于网络差的环境

   - 数据传输过程

      1. 发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。
      2. 发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机。
      3. 目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。

   - 三次握手（建立连接）- 客户端和服务器端

      > 客户端向服务器发送消息**报文**请求连接
      > 服务器收到请求后，回复报文确定可以连接
      > 客户端收到回复，发送最终报文连接建立
      >
      > 发送请求 -> 回复报文 -> 建立连接

   - 四次挥手（断开连接）- 主动方和被动方

      > 主动方发送报文请求断开连接
      > 被动方收到请求后，立即回复，表示准备断开
      > 被动方准备就绪，再次发送报文表示可以断开
      > 主动方收到确定，发送最终报文完成断开
      >
      > 主发请求 -> 被发回复 -> 被发再发 -> 主发完成

###### 56. HTTP协议：超文本传输协议

   - 特征
      1. 应用层协议，传输层使用TCP传输；
      2. 无状态，协议不记录传输内容
      3. http1.1支持持久连接，丰富了请求类型
         - HTTP1.0定义了三种请求方法：GET/POST/HEAD
         - HTTP1.1新增了五种请求方法：PUT/OPTIONS/DELETE/TRACE/CONNECT
   - 响应码

###### 57. 多进程多线程

   - 目的

      1. 充分利用计算机的多核资源
      2. “同时”处理多个应用程序任务

   - 系统如何产生一个进程

      1. 用户空间通过调用程序接口或命令发起请求
      2. 操作系统接受用户请求，开始创建进程
      3. 操作系统调配计算机资源，确定进程状态等
      4. 操作系统将创建的进程提供给用户使用

   - 进程状态：ps aux

      1. 就绪态：进程具备执行条件，等待分配cpu资源
      2. 运行态：进程占有cpu时间片正在运行
      3. 等待态：进程暂时停止运行，让出cpu
      4. 新建：创建一个进程，获取资源的过程
      5. 终止：进程结束，释放资源的过程

   - 多进程特征：（from multiprocessing import Process, pool）

      1. 可以充分利用计算机的多核资源
      2. 每个进程拥有独立的运行空间，进程之间独立，互不影响
      3. 进程的创建和销毁过程消耗的资源较多

   - 多线程特征：threading

      1. 一个进程中至少包含一个线程
      2. 线程的创建和销毁资源比较小
      3. 一个线程中的所有线程共享这个进程的资源
      4. 多个线程对共享资源的争夺需要同步互斥处理，如设置线程锁

   - 死锁产生的原因

      1. 当前线程拥有其他线程需要的资源
      2. 当前线程等待其他线程已拥有的资源
      3. 都不放弃自己拥有的资源

   - 孤儿进程和僵尸进程

      1. 父进程先于子进程退出，此时子进程成为孤儿进程
      2. 子进程本应该结束退出，但父进程不能完全处理子进程的退出状态，导致子进程残留在内存中形成僵尸进程

   - 如何避免僵尸进程产生

      1. 使用**wait函数**处理子进程退出

      2. 使用**信号signal**处理子进程退出

         > 原理： 子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动处理子进程退出。

###### 58. Python的全局解释器锁GIL

   > python解释器同一时刻只能解释执行一个线程
   >
   > 因为遇到阻塞时线程会主动让出解释器，所以Python多线程在执行IO密集型任务是仍然能够显著提升效率

###### 59. 数据库优化

    1. 数据库表设计（六种范式）
     
    2. 存储引擎的选择：
    
       - 执行**查操作**多的表用MyISAM
       - 执行**写操作**多的表用InnoDB
    
    3. 字段数据类型选择
    
    4. 键的设置
    
       1. 设置占用空间小的字段为主键
       2. 在表关联时在**关联键**上建立索引，可以提高查找速度
    
    5. explain语句
    
       > 用来分析SQL查询语句，查找性能瓶颈在哪里
    
    6. SQL优化
    
       1. 尽量选择数据类型占空间少
       2. 在where ，group by，order by中出现的频率高的字段建立索引
       3. 尽量避免使用 select * …;用具体字段代替 * ,不要返回用不到的任何字段
       4. 少使用like %查询，否则会全表扫描
       5. 子查询优化为join查询
       6. 避免全表扫描
          1. 单条查询最后添加 LIMIT 1，停止全表扫描
          2. where子句中不使用 != ,否则放弃索引全表扫描
          3. 尽量避免 NULL 值判断,否则放弃索引全表扫描
          4. 尽量避免 or 连接条件,否则会放弃索引进行全表扫描，可以用union代替
          5. 尽量避免使用 in 和 not in,否则会全表扫描
       7. 表的拆分
          1. 垂直拆分
          2. 水平拆分

###### 60. celery

   > 分布式系统，生产者消费者模型
   >
   > 实时处理**任务队列**和支持**任务调度**

   1. 消息中间件

       > 接受生产者发来的任务消息，将任务存入队列（redis）

   2. 任务执行单元worker

       > worker实时监控**消息队列**，获取调度的任务并执行

   3. 任务结果存储backend

       > 存储任务的执行结果(redis)

   4. 异步任务

       - 创建一个celery实例（\_\_init.py__、celeryconfig.py、task.py）
       - 启动celery work（实时监控消息队列，终端中下发指令）
       - 程序调用异步任务（xxx.delay()）

   5. 定时任务

       > **celery beat**进程通过读取配置文件的内容，周期性地将定时任务发往任务队列
       >
       > 可以将celery beat看成生产者，celery work是消费者
       >
       > work进程和beat进程都要在终端中下发指令来启动
###### 61. 字典和json的区别有哪些？
> 字典是一种数据结构，json是一种数据的表现形式，字典的key值只要能hash即可，而json必须是字符串。
- 字典和json字符串相互转化
	> json.dumps() 可以将字典转json字符串，而json.loads()可以将json字符串转字典。import json
	```python
	import json
	
	d = {'name': 'tom'}
	res = json.dumps(d)
	print(res, type(res))
	
	ret = json.loads(res)
	
	print(ret, type(ret))
	```