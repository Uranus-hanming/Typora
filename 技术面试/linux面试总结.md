[toc]
### 内容一：

---

###### 操作系统的作用

> 操作系统除了有效控制***硬件资源的分配***，并提供计算机运行所需要的功能（如网络功能）之外，为了要提供程序员更容易开发软件的环境，操作系统也会***提供一整组系统调用接口***。

###### 功能组合键

> 辅助我们进行命令的编写与程序的中断。

- Tab按键

  > 具有***命令补全与文件补齐***的功能。重点是可以避免我们打错命令或文件名。
  >
  > Tab接在一串命令的第一个字段后面，则为命令补全；
  >
  > Tab接在一串命令的第二个字段后面，则为文件补齐。

- Ctrl -c 按键

  > 中断目前程序的按键

- Ctrl -d 按键

  > 代表：键盘输入结束（End Of File, EOF 或 End Of Input）的意思；
  >
  > 也可以用来去掉exit的输入。例如你想直接离开命令行模式，可以直接按下ctrl + d 就能够直接离开（相当于输入exit）

- shift + Page Up / Page Down按键

  > 翻页功能

###### 超简单的文本编辑器：nano

> 指数符号^代表的是键盘的ctrl按键

##### linux命令

> command   [-options]   parameter1   parameter2   ...
>
> 命令		选项		参数（1）	参数（2）
>
> 命令之后的选项除了前面带减号[ - ]之外，某些特殊情况下，选项或参数前面也会带正号 [ + ]的情况。
>
> 1. 一行命令中第一个输入的部分绝对是命令（command）或可执行文件（例如shell脚本）；
> 2. command为命令的名称；
> 3. 中括号[]并不存在于实际的命令中，表示是可选的，而加入选型设置时，通常选项前会带 - 号，例如 -h；有时候会使用选项的完整全名，则选项前带有 -- 符号，例如 --help;
> 4. parameter1  parameter2 为依附在选项后面的参数，或是command的参数；
> 5. 命令、选项、参数等这几个东西中间以空格来区分，不论空几格shell都视为一格，所以空格是很重要的特殊字符；
> 6. 按下回车键后，该命令就立即执行，回车键代表着一行命令的开始启动。
> 7. 命令太长的时候，可以使用反斜杠（\）来转义回车键，使命令连续到下一行，注意，反斜杠后就立即接着特殊字符才能转义。
> 8. 在linux系统中，英文大小写字母是不一样的；

- --help:几乎Linux上面的命令，在开发的时候，开发者就将可以使用的命令语法与参数写入命令操作过程中。只要使用--help就能够将命令的用法作一个大致的理解。

- man

  > 按下空格键往下翻页，可以按下q按键来离开

- info page

  > info与man的用途差不多，都是用来查询命令的用法或是文件的格式。但是与man page一口气输出一堆信息不同的是，info page则是将文件数据拆成一个一个的段落。每个段落用自己的页面来编写，并且在各个页面中还有类似网页的超链接来跳到各不同的页面中，每个独立的页面也被成为一个节点。

- ctrl + alt +F1-F6: 命令行模式登陆tty1-tty6终端

- 正常关机的命令：

  - 将数据同步写入硬盘中的命令：sync
  - 常用的关机命令：shutdown
  - 重新启动，关机：reboot, halt, poweroff

- 显示日期与时间：date

- 显示日历：cal(calendar 日历)

- 简单好用的计算器：bc

- cd:切换目录(change directory)

- pwd:显示当前目录(print working directory)

- mkdir:建立一个新目录(make directory)

- touch:修改文件时间或创建新文件

  > ls -l --time=ctime/atime: 读取状态时间和读取时间；ls默认显示出来的是该文件的mtime.

  - 修改时间（modification time, mtime）

    > 当该文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限。

  - 状态时间（status time, ctime）

    > 当该文件的状态改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间

  - 读取时间（access time, atime）

    > 当该文件的内容被读取时，就会更新这个读取时间，举例来说，我们使用cat去读取时，就会更新该文件的atime

- rmdir:删除一个空目录(remove directory)

- cp (copy):复制文件、建立链接文件（就是快捷方式）、比对两文件的新旧而予以更新、复制整个目录等。

- mv(move):移动目录与文件、直接拿来做重命名的操作。

- rm(remove):删除

- echo $PATH

  > 当我们在执行一个命令的时候，系统会依照PATH的设置取每个PATH定义的目录下查找文件名的可执行文件，如果在PATH定义的目录中含有多个文件名的可执行文件，那么先查找到的同名命令先被执行。

- 文件内容查看

  - cat从第一行开始显示文件内容；
  - tac从最后一行开始显示，可以看出tac是cat倒着写；
  - nl显示的时候，同时输出行号；
  - more一页一页地显示文件内容；
  - less与more类似，但是比more更好的是，它可以往前翻页；
  - head 取出前面几行；
  - tail只看后面几行；
  - od以二进制的方式读取文件内容。

- 文件默认权限：umask

- chattr (配置文件隐藏属性)

- lsattr (显示文件隐藏属性)

- 文件特殊权限：SUID/SGID/SBIT

- 观察文件类型：file

- type：查询命令是否为Bash shell的内置命令

- env：列出当前环境下的所有环境变量及其内容

- history


###### 命令与文件的查找

- which: 后面接的是完整文件名；若加上-a选项，则可以列出所有的可以找到的同名执行文件，而非仅显示第一个而已。

- whereis: 只找系统中某些特定目录下面的文件而已

- locate：是利用数据库来查找文件名，直接在后面输入文件的部分名称后，就能得到结果。

- find:很强大的查找命令，但是所用时间很多；

- df(disk free): 列出文件系统的整体磁盘使用量；

- du(disk usage): 查看文件系统的磁盘使用量（常用在查看目录所占磁盘空间）；

- lsblk（list block device）: 列出系统上的所有磁盘列表；

- 

- updatedb:

  > 会去读取/etc/updatedb.conf这个配置文件的设置，然后再去硬盘里面进行查找文件名的操作，最后就更新整个数据库文件。因为updatedb会去查找硬盘，所以当你执行updatedb时，可能会等待数分钟的时间。

###### Linux文件权限

> Linux下面所有的命令与能够执行的操作都与权限有关，而系统是通过UID/GID来判断权限。

- ls(list) / ls -al/ll

  > -al:表示列出所有的文件详细的权限与属性（包含隐藏文件）
  >
  > 七个字段的每个意思：
  >
  > 文件类型权限  链接数  文件拥有者  文件所属用户组  文件大小  文件最后被修改的时间(mtime)  文件名

  - 第一栏代表这个文件的类型与权限
    - 第一个字符代表这个文件是目录(d)、文件(-)或链接文件(l)等（b则表示为设备文件里面的可供存储的周免设备；c则表示为设备文件里面的串行端口设备）
    - r(4)代表可读read，w(2)代表可写write，x(1)代表可执行execute
      - 第一组为文件拥有者（owner）可具备的权限；
      - 第二组为加入此用户组之账号（group）的权限；
      - 第三组为非本人且没有加入本用户组（other）的其他账号的权限；

- sudo su:切换身份成为root

  > su - username:切换用户

- 修改文件属性与权限

  - chgrp(change group):修改文件所属用户组
  - chown(change owner):修改文件拥有者
  - chmod(change mode):修改文件的权限，SUID, SGID, SBIT等的特性

- 文件扩展名

  > Linux系统上的文件名只是让你了解该文件可能的用途而已，真正的执行与否仍然需要***权限的规范***才行。

  - *.sh:脚本或批处理文件；
  - *Z、\*.tar、\*.tar.gz、\*.zip、\*.tgz：经过打包的压缩文件；
  - *.html、\*.php：网页相关文件。

##### Linux文件目录

- /bin

  > 系统有很多存放执行文件的目录；

- /boot

  > 主要放置启动会使用到的文件，包括Linux内核文件以及启动选项与启动所需配置文件等。

- /dev(device)

  > 在Linux系统上，任何设备与接口设备都是以文件的形式存在于这个目录中。只要通过读写这个目录下面的某个文件，就等于读写某个设备。

- /etc

  > 系统主要的配置文件几乎都放置在这个目录内。

- /lib

  > 系统的函数库

- /media

  > 放置可删除的设备，包括软盘、光盘、DVD等设备都暂时挂载于此。

- /mnt(mount 攀登)

  > 挂载某些额外的设备

- /opt

  > 给第三方辅助软件放置的目录。

- /run

  > 放置系统启动后所产生的各项信息

- /sbin

  > 放置启动过程所需要的，里面包括启动、修复、还原系统所需要的命令。

- /srv

  > srv可以视为service的缩写，是一些网络服务启动之后，这些服务所需要使用的数据目录。

- /tmp

  > 这是让一般用户或是正在执行的程序暂时放置文件的地方。

- /usr

  > UNIX Software Resource的缩写，UNIX操作系统软件资源所放置的目录

  - /usr/bin/

    > 所有一般用户能够使用的命令都放在这里。使用链接文件的方式将/bin链接至此，即/usr/bin与/bin一模一样。

  - /usr/lib/

    > 与/lib功能相同，所以/lib就是链接到此目录中的。

  - /usr/local/

    > 系统管理员在本机安装自己下载的软件。

  - /usr/sbin/

    > /sbin链接到此目录中

  - /usr/share/

    > 主要放置只读的数据文件，当然也包括共享文件。

  - /usr/games/

    > 与游戏比较相关的数据放置处

  - /usr/include/

    > c/c++等程序语言的头文件（head）与包含文件（include）放置处，当我们以Tarball（*.tar.gz）方式安装某些程序时，会使用到里面的许多文件。

  - /usr/libexec

    > 放置某些不被一般用户常用的执行文件或脚本等。

  - /usr/lib<qual>/

    > /lib<qual>链接到此目录

  - /usr/src/

    > 一般源代码建议放置到这里，src有source的意思。至于内核源代码则建议放置到/usr/src/Linux/目录下

- /var(variable)

  > 主要放置变动性的数据，包括缓存（cache）、日志文件（log file）以及某些软件运行所产生的文件，包括程序文件（lock file、run file），例如MySQL数据库的文件等。

  - /var/cache/

    > 应用程序本身运行过程中会产生的一些缓存。

  - /var/lib/

    > 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。

  - /var/lock/

    > 某些设备或是文件资源一次只能被一个应用程序所使用，如果同时又两个程序使用该设备时，就可能产生一些错误的状况，因此就得要该设备上锁，以确保该设备只会给单一软件使用。

  - /var/log/

    > 这是日志文件放置的目录。

  - /var/mail/

    > 放置个人电子邮箱的目录

  - /var/run/

    > 某些程序或是服务启动后，会将他们的PID放置在这个目录下。

  - /var/spool

    > 这个目录通常放置一些队列数据，所谓的队列就是排队等待其他程序使用的数据，这些数据被使用后通常都会被删除。

- /home

  > 系统默认的洪湖家目录

- /root

  > 系统管理员的家目录

- /lost+found

  > 这个目录是使用标准的ext2, ext3, ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时，将一些遗失的片段放置到这个目录下。

- /proc

  > 这个目录本身是一个虚拟文件系统，它放置的数据都是在内存当中，例如系统内核、进程信息、外接设备的状态及网络转台等。本身不占据任何硬盘空间。

- /sys

  > 也是一个虚拟的文件系统，主要也是记录内核与系统硬件信息相关的内容。不占据硬盘空间。

###### 硬连接 ln

> 硬连接只是在某个目录下新增一条文件名链接到某inode号码的关联记录而已。

###### 文件与文件系统的压缩

- 压缩文件的扩展名：

  ```
  *.tar：tar程序打包的文件，并没有压缩
  *.tar.gz：tar程序打包的文件，并且经过gzip的压缩
  *.tgz
  *.gz：gzip程序压缩的文件
  *.zip：zip程序压缩的文件
  *.Z：
  *.bz2
  *.xz
  ```

- gzip

- tar

  - linux解压tar.gz文件

    ```
    tar -zxvf xxx.tar.gz -c /xxx/
    -z是使用gzip来解压或者压缩文件

    -x是释放文件，或者说叫解压文件

    -v是报告文件详情信息，如果不加这一条的话，就不会一直滚动的信息条了，建议加上，如果出了错还是会更加直观的看出来是什么原因

    -f是指定名字
    ```

  - 压缩文件

    ```
    tar zcvf FileName.tar.gz DirName
    ```

- zip

##### vi/vim

###### 一般命令模式

> [[上下左右]按键移动光标、删除字符、删除整行、复制、粘贴等

- 光标的移动
  1. 上下左右箭头移动（n+箭头：即向指定方向移动n步）
  2. 向上向下翻页（ctrl+f、ctrl+b、ctrl+d、ctrl+u）
  3. +/-:光标移动到非空格符
  4. [home]/[end]:移动到当行的最前/后的字符处
  5. ctrl+Home/End:光标移动到本文件的第一行(gg)/最后一行
  6. nG:移动到本文件的地n行
- 查找与替换
  1. /word:向光标**之下**寻找一个名称为word的字符串；
  2. ?word:向光标之上寻找一个名称为word的字符串；
  3. n：重复前一个查找的操作；
  4. N：与n刚好相反；
  5. :n1,n2/word1/word2/g：在n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2；
  6. :1,$s/word1/word2/g：从第一行到最后一行寻找word1字符串，并将该字符串替换为word2；
  7. :1,$s/word1/word2/gc：从第一行到最后一行寻找word1字符串，并将该字符串替换为word2，且在替换前显示提示字符给用户确认是否需要替换；
- 删除
  1. x与X：在一行中，x为向后删除一个字符；X为向前删除一个字符；
  2. nx/X：向后或向前删除n个字符；
  3. dd：删除（剪切）光标所在的那一整行；
  4. ndd：n为数字，删除（剪切）光标所在的向下n行；
  5. dnG：n为数字，删除（剪切）光标所在到第n行的所有数据；
  6. dG：删除（剪切）光标所在到最后一行的所有数据；
  7. d$：删除（剪切）光标所在处，到该行的最后一个字符；
  8. d0：删除（剪切）光标所在处，到该行的最前面一个字符；
- 复制
  1. yy：复制光标所在的那一行；
  2. nyy：n为数字，复制光标所在的向下n行；
  3. ynG：n为数字，复制光标所在到第n行的所有数据；
  4. yG：复制光标所在到最后一行的所有数据；
  5. y$：复制光标所在处，到该行的最后一个字符；
  6. y0：复制光标所在处，到该行的最前面一个字符；
- 其他常用操作
  1. 鼠标左键选取内容，右键粘贴至光标的后面（复制粘贴最快速的方式）；
  2. p与P：p为将已复制的数据在光标下一行粘贴；P则为贴在光标上一行；
  3. J：将光标所在行与下一行的数据结合成同一行；
  4. u：撤销，即恢复前一个操作；
  5. .：小数点，重做上一个操作

###### 编辑模式

> i 进入编辑模式；
>
> Esc 退出编辑模式或命令行模式

###### 命令行模式

> [: / ?] - 从一般模式进入命令行模式；
>
> 查找数据、读取、保存、批量替换字符、退出vi、显示行号等操作

- :w ：将编辑的数据写入硬盘文件中；
- :w!：若文件属性为【只读】时，强制写入该文件；
- :q ：退出vi；
- :q!：若曾修改过文件，又不想保存，使用！为强制退出不保存；
- :wq：保存后退出，若为:wq!则为强制保存后退出；
- ZZ：大写的z，若文件没有修改，则不保存退出；若文件已经被修改过，则保存后退出；
- :w [filename]：将编辑的数据保存成另一个文件，类似另存为新文件；
- :r [filename]：在编辑的数据中，读入另一个文件的数据，亦即将[filename]这个文件内容加到光标所在行后面；
- :set nu：显示行号，设置之后，会在每一行的前缀显示该行的行号；
- :set nonu：取消行号

###### vim多文件编辑

- vim file1 file2：使用vim打开两个文件；
- :n ：编辑下一个文件；
- :N ：编辑上一个文件；
- :files ：列出目前这个vim开启的所有文件

###### 多窗口功能

- :sp ：打开一个新窗口，如果有加filename，表示在新窗口创建一个新文件，否则表示两个窗口为同一个文件内容；
- ctrl+w+↑/↓：先按下ctrl不放，在按下w后放开所有的按键，之后再按下↑/↓，则光标可向上或下窗口移动；
- ctrl+w+q：先按下ctrl不放，在按下w后放开所有的按键，之后再按下q，即可退出光标所在的窗口

##### 认识与学习BASH

###### 数据流重定向

- 标准输入（stdin）：代码为0，使用<(会覆盖之前的数据) 或 <<(追加模式)；
- 标准输出（stdout）：代码为1，使用>(会覆盖之前的数据) 或 >>(追加模式)；
- 标准错误输出(stderr)：代码为2，使用2> 或 2>>
- 将正确与错误数据写入同一个文件中：&> filename（> filename 2>&1）

###### 命令执行的判断依据

- cmd; cmd（不考虑命令相关性的连续命令执行）
- cmd1 &&(and) cmd2
  1. 若cmd1执行完毕且正确执行，则开始执行cmd2；
  2. 若cmd1执行完毕且为错误，则cmd2不执行；
- cmd1 ||(or) cmd2
  1. 若cmd1执行完毕且正确执行，则cmd2不执行；
  2. 若cmd1执行完毕且为错误，则开始执行cmd2；

###### 管道命令|（pipe）

- 管道命令仅会处理***标准输出***，对于标准错误会予以忽略；
- 管道命令必须要能够接受来自前一个命令的数据成为标准输入继续处理才行；

###### 选取命令：cut、grep

> 将一段数据经过分析后，取出我们所想要的，或是经由分析关键词，取得我们所想要的那一行。

- cut

  > 将一段信息的某一段给它切出来，处理的信息是以行为单位；
  >
  > cut主要的用途在于将同一行里面的数据进行分解，最常使用在分析一些数据或文字数据的时候。
  >
  > 将PATH变量取出，然后找出第五个路径：echo $PATH | cut -d ':' -f 5
  >
  > 将export输出的信息，取得第12字符以后的所有字符：export | cut -c 12-

- grep

  > grep是分析一行信息，若当中有我们所需要的信息，就将该行拿出来；

###### 排序命令：sort、wc、uniq

- sort

  > 可以根据不同的数据形式来排序；
  >
  > /etc/passwd 内容是以:来分隔的，以第三栏来排序：cat /etc/passwd | sort -t ':' -k 3

- wc

  > 可以计算输出信息的整体数据；
  >
  > 查询目前账号文件中有多少个账号：cat /etc/passwd | wc -l

- uniq

  > 这个命令用来将重复的行删除掉只显示一个；

###### 双向重定向：tee

> tee会同时将数据流分送到文件与屏幕，而输出到屏幕的，其实是stdout；
>
> ls -l /home | tee ~/homefile | more

###### 字符转换命令： tr、col、join、paste、expand

- tr

  > tr可以用来删除一段信息当中的文字，或是进行文字信息的替换；
  >
  > 将last输出的信息中，所有的小写变成大写字符：last | tr '[a-z]' '[A-Z]'

- col

  > 将tab键转换成对等的空格键：col -x

- join

  > 处理两个文件之间的数据（两个文件中，有相同数据的那一行，才将它加在一起）

- paste

  > 直接将两行贴在一起，且中间以tab键隔开；

- expand

  > 将tab案件转成空格键；

###### 划分命令：split

> 将一个大文件，依据文件大小或行数来划分，可以将大文件划分成为小文件；

###### 参数代换：xargs

> 要使用xargs的原因是，很多命令其实并不支持管道命令，因此可以通过xargs来提供该命令使用标准输入；

###### 关于减号 - 的用途

> 在管道命令当中，常常会使用到前一个命令的stdout作为这次的stdin，某些命令需要用到文件名来进行处理时，该stdin与stdout可以利用减号“-”来替代

##### 计划任务（crontab）

###### at

> at是个可以处理仅执行一次就结束的命令，要执行at，必须有atd这个服务。
>
> 使用at这个命令来产生所要运行的任务，并将这个任务一文本文件的方式写入/var/spool/at/目录中，该任务便能等待atd这个服务的使用与执行了。

- 重新启动atd服务：systemctl restart atd

- 让atd服务开机就自动启动：systemctl enable atd

- 查看atd目前的状态：systemctl status atd

- 为了安全，可以利用/etc/at.allow与/etc/at.deny这两个文件来实现对at的使用限制，at的工作情况如下：

  1. 先找寻/etc/at.allow这个文件，写在这个文件中的用户才能使用at，没有在这个文件中的用户则不能使用at（即使没有卸载at.deny）中；
  2. 如果/etc/at.allow不存在，就查找/etc/at.deny这个文件，写在这个at.deny中的用户则不能使用at，而没有在这个at.allow文件中的用户，就可以使用at；
  3. 如果两个文件都不存在，那么只有root可以使用at这个命令。

- 实际运行单一计划任务

  > at [-mldv] TIME
  >
  > 再过五分钟：at now + 5 minutes

- 脱机继续执行的任务：

  > 由于at计划任务的使用，系统会将该项at任务独立出你的bash环境，直接交给系统的atd程序来接管。因此，当你执行了at的任务之后就可以立刻脱机了，剩下的工作就完全交给Linux管理。

- at常用命令：

  - atq:查询目前主机上面有多少的at计划任务
  - atrm 3: 将第三个任务删除

###### crontab

> crontab这个命令所设置的任务将会循环地一直执行下去，可循环的时间为分钟、小时、每周、每月或每年等。
>
> 循环执行的计划任务是由cron(crond)这个系统服务来空值的；
>
> crontab是Linux提供用户空值计划任务的命令；
>
> crontab的执行可以通过：命令，或者编辑/etc/crontab；
>
> 让crontab可以生效的服务是crond。

- 为了避免安全性问题，可以限制使用crontab的账号：

  - /etc/cron.allow

    > 将可以使用crontab的账号写入其中，不在这个文件内的用户则不可使用crontab

  - /etc/cron.deny

    > 将不可以使用crontab的账号写入其中，未记录到这个文件当中的用户，就可以使用crontab

- crontab的语法

  > crontab [-u username] \[-l | -e | -r]
  >
  > -u ： 只有root才能执行这个任务，亦即帮其他使用者建立/删除crontab计划任务；
  >
  > -e ： 编辑crontab的任务内容；
  >
  > -l ： 查看crontab的任务内容；
  >
  > -r ： 删除所有的crontab的任务内容，若仅要删除一项，请用-e去编辑。
  >
  > 重新启动crond服务：systemctl restart crond

  ```shell
  # 用charles的身份在每天的12:00发信给自己
   0  12 *  *  * mail -s "at 12:00" charles < /home/charles/.bashrc
  #分 时 日 月 周 |<=====================命令串====================>|
  ```

| 代表的意义 | 分钟 | 小时 | 日期 | 月份 | 周   | 命令           |
| ---------- | ---- | ---- | ---- | ---- | ---- | -------------- |
| 数字范围   | 0-59 | 0-23 | 1-31 | 1-12 | 0-7  | 需要执行的命令 |

| 特殊字符 | 代表意义                                     |
| -------- | -------------------------------------------- |
| *        | 代表任何时刻都接受的意思                     |
| ,        | 代表分隔时段的意思                           |
| -        | 代表一段时间范围内                           |
| /n       | 那个n代表数字，亦即是【每隔n单位间隔】的意思 |

- 系统的配置文件：/etc/crontab 、/etc/cron.d/*

  > 1. 可以编辑/etc/crontab这个文件来执行【系统的例行性任务】；设置分为七栏，【分、时、日、月、周、执行者、命令】为其设置根据；
  > 2. crontab -e这个crontab其实是/usr/bin/crontab这个执行文件；分为六栏，【分、时、日、月、周、命令】为其设置根据；
  > 3. cron这个服务的最低检测限制是分钟，所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron

- crond服务读取配置文件的位置

  > 跟系统的运行有关系的两个配置文件是/etc/crontab文件以及/etc/cron.d/*目录内的文件；
  >
  > 跟用户自己的任务有关系的配置文件，就是放在/var/spool/cron里面的文件；

  - /etc/crontab（是大家都能够读取的权限）
  - /etc/cron.d/*
  - /var/spool/cron/*

- crontab的基本应用

  - 个人话的操作使用【crontab -e】
  - 系统维护管理使用【vim /etc/crontab】
  - 自己开发软件使用【vim /etc/cron.d/newfile】：如果你是想要自己开发软件，当然最好就是使用全新的配置文件，并且放置于/etc/cron.d/目录内即可。
  - 固定每小时、每日、每周执行的特别任务：如果与系统运维有关，还是建议放置到/etc/crontab中集中管理较好。

###### anacron

> anacron是一个程序并非一个服务，配置文件放置在/etc/cron.hourly
>
> anacron存在的目的是，用于处理非24小时运行的Linux系统所执行的crontab，以及因为某些原因导致的超过时间而没有被执行的任务。
>
> 其实anacron也是每小时被crond执行一次，然后anacron再去检测相关的计划任务有没有被执行，如果有超过期限的任务，就执行该任务，执行完毕或无须执行任何任务时，anacron就停止。
>
> 由于anacron默认会以一天、七天、一个月为期去检测系统未执行的crontab任务，因此对于某些特殊的使用环境非常有帮助。
>
> anacron是怎么知道我们的系统啥时候关机的呢？这就要使用anacron读取的时间记录文件（timestamps）了。anacron会去分析现在的时间与时间记录文件所记载的上次执行anacron的时间，两者比较后发现有差异，那就是在某些时刻没有执行crontab，此时anacron就会开始执行未执行的crontab任务了。

- anacron [-sfn] \[-sfn] \[job] ..
- anacron的配置文件/etc/anacrontab



- 执行日志文件的轮询（logrotate）

  > logrotate的任务：将日志文件数据移动，让旧的数据与新的数据分别存放，让系统更有效地记录登陆信息，提高文件的读写性能。

- 日志文件分析logwatch的任务

  > 如果系统发生了软件问题、硬件错误、信息安全问题等，绝大部分的错误信息都会被记录到日志文件中。
  >
  > logwatch程序会主动分析登陆信息。

- 建立locate的数据库

  > 文件名数据库放置在/var/lib/mlocate中；
  >
  > 系统会主动地执行updatedb来更新数据库；

- manpage查询数据库的建立

  > 要使用manpage数据库，就要执行mandb才能建立好；

- RPM软件日志文件的建立

  > RPM数据库，将文件名作排序的记录

- 删除缓存

  > 系统通过计划任务执行名为tmpwatch的命令来删除缓存；

- 与网络服务有关的分析操作

  > 如果你安装了类似网站服务器的软件，那么你的Linux系统通常就会主动地分析该软件的日志文件。

##### 进程管理

> 在Linux系统中：触发任何一个事件时，系统都会将它定义成为一个进程，并且给予这个进程一个ID，成为PID，同时根据触发这个进程的用户与相关属性关系，给予这个PID一组有效的权限设置。

- 如何产生一个进程？

  > 执行一个程序或命令就可以触发一个事件而获取一个PID；
  >
  > 程序：通常为***二进制程序***，放置在存储媒介中（如硬盘、光盘、软盘、磁带等），以物理文件的形式存在；
  >
  > 进程：程序被触发后，执行者的权限与属性、程序的代码与所需数据等都会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID），可以说进程就是一个正在运行中的程序。

- 每个进程都有三组权限，每组都具有r、w、x的权限，所以不同的用户身份执行程序时，系统给予的权限也都不相同；

###### fork and exec：程序调用的流程

> Linux的程序调用通常称为***fork-and-exec的流程***。进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec的方式实际要执行的进程，最终就成为一个子进程。

###### 系统或网络服务：常驻在内存的进程

> 常驻在内存当中的进程通常都是负责一些系统所提供的功能以服务用户的各项任务，因此这些常驻进程就会被称为：服务。
>
> 系统的服务非常多，主要分成**系统本身所需要的服务（例如crond、atd和rsyslogd等）**和**负责网络连接的服务（例如apache、named、postfix、vsftpd等）**。
>
> 网络服务的进程被执行后，它会启动一个可以负责网络监听的端口（port），以提供外部客户端（client）的连接请求。
>
> 一般daemon类型的进程都会在文件名后面加上d，比如：crond、atd、httpd、vsftpd等

###### Linux的多人多任务环境

> 在Linux下面执行一个命令时，系统会将相关的权限、属性、进程代码与数据等均加载到内存，并给予这些进程一个进程标识符（PID），最终该命令可以执行的任务则与这个PID的权限有关。

###### 查看进程

- ps(Process Status)：将某个时间点的进程运行情况取下来

  ```
  ps -l：只能看自己bash的进程；
  ps aux：查看系统所有的进程；
  ps -lA：也是能够查看所有系统的进程；
  ps axjf：连同部分进程树状态
  选项与参数：
  	-A：所有的进程均显示出来，与-e具有相同的效果；
  	-a：不显示与终端有关的所有进程；
  	-u：有效使用者（effective user）相关的进程；
  	x：通常与a这个参数一起是个，可列出较完整信息
  输出格式规划：
  	l：较长、较详细的将该PID的信息列出；
  	j：任务的格式（jobs format）；
  	-f：做一个更为完整的输出
  ```

###### 仅查看自己的bash相关进程：ps -l

- F：代表这个进程标识（process flags），说明这个进程的权限，常见号码有：
  - 若为4，表示此进程的权限为root；
  - 若为1，表示此子进程仅执行复制（fork），而没有实际执行（exec）
- S：代表这个进程的状态（STAT），主要的状态有：
  - R（Running）：该进程正在运行中；
  - S（Sleep）：该进程目前正在睡眠状态（idle），但可以被唤醒（signal）；
  - D：不可被唤醒的睡眠状态，通常这个进程可能在等待I/O的情况（ex>打印）；
  - T：停止状态（stop），可能是在任务空值（后台暂停）或跟踪（traced）状态；
  - Z（Zombie）：僵尸状态，进程已经终止但无法被删除至内存外
- UID/PID/PPID：代表【此进程被该UID所拥有/进程的PID号码/此进程的父进程PID号码】
- C：代表CPU使用率，单位为百分比
- PRI/NI：Priority[praɪˈɔːrəti]/Nice的缩写，代表此进程被CPU所执行的优先级，数值越小代表该进程越快被CPU执行。
- ADDR/SZ/WCHAN：都与内存有关，ADDR是kernel function，指出该进程在内存的哪个部分，如果是个running的进程，一般就会显示[ - ]；SZ代表此进程用掉多少内存；WCHAN表示目前进程是否运行，同样的，若为-表示正在运行中。
- TTY：登陆者的终端位置，若为远程登录则使用动态终端接口名称（pts/n）；
- TIME：使用的CPU时间，注意，是此进程实际话费CPU运行的时间，而不是系统时间；
- CMD：就是command的缩写，表示造成此进程的触发进程的命令是什么。

###### 查看系统所有进程：ps aux

- USER：该进程属于所属用户账号；
- PID：该进程的进程ID；
- %CPU：该进程使用掉的CPU资源百分比；
- %MEM：该进程所占用的物理内存百分比；
- VSZ：该进程使用掉的虚拟内存量（KB）；
- RSS：该进程占用的固定的内存量（KB）；
- TTY：该进程是在哪个终端上面运行，若与终端无关则显示？另外，tty1-tty6是本机上面的登录进程，若为pts/0等，则表示是由网络连接进入主机的进程；
- STAT：该进程目前的状态，装填显示与ps -l的S的标识相同（R/S/T/Z）；
- START：该进程被触发启动的时间；
- TIME：该进程实际使用CPU运行的时间；
- COMMAND：该进程的实际命令是什么

###### 僵尸（zombie [ˈzɑːmbi] ）进程

> 造成僵尸进程的原因在于该进程应该已经执行完毕，或是应该要终止了，但是该进程的父进程却无法完整地将该进程结束掉，而造成该进程一直存在内存当中；如果你发现在某个进程的CMD后面接上了\<defunct>时，就代表该进程是僵尸进程。

- 如果发现系统中有很多僵尸进程时，记得要找出该进程的父进程，然后好好做个追踪，好好进行主机的环境优化，看看有什么地方需要改善，不要只是直接将它kill掉；
- 通常僵尸进程都已经无法管理，而直接交给systemd这个进程来负责，偏偏systemd是系统第一个执行的进程，它是所有进程的父进程。如果产生僵尸进程，而系统过一阵子还没有用过内核非经常性的特殊处理来将该进程删除时，那只好通过reboot的方式来将该进程kill掉。

###### top：动态查看进程的变化

> 相比于ps是选取一个时间点的进程状态，top则可以持续监测进程运行的状态。

```
top [-d数字] | top [-bnp]
选项与参数：
-d：后面可以接秒数，就是整个进程界面更新的秒数，默认是5秒；
-b：以批量的方式执行top，还有更多的参数可以使用，通常会搭配数据流重定向来将批量的结果输出为文件；
-n：与-b搭配，意义是，需要执行几次top的输出结果；
-p：指定某些个PID来执行查看监测；
在top执行过程当中可以使用的按键命令：
	？：显示在top当中可以输入的按键命令；
	p：以CPU的使用排序显示；
	M：以Memory的使用排序显示；
	N：以PID来排序；
	T：由该进程使用的cpu时间累积（TIME+）排序；
	k：给予某个PID一个信号（signal）；
	r：给予某个PID重新制定一个nice值；
	q：退出top的按键
	
top上面的界面为整个系统的资源使用状态：
第一行（top...）：这一行显示的信息分别为：
	1.目前的时间；
	2.开机到目前为止所经过的时间；
	3.已经登录系统的用户人数；
	4.系统在1、5、15分钟的平均任务负载
第二行（Tasks...）：显示的是目前进程的总量与个别进程在什么状态（running,sleeping/stopped,zombie）
第三行（%CPU...）：显示的是CPU的整体负载，每个项目可使用？（问好）查看。
第四行与第五行：表示目前的物理内存与虚拟内存（Mem/Swap）的使用情况。
第六行：这个是在top进程当中输入命令时，显示状态的地方。

top下半部分的画面，则是每个进程使用的资源情况：
	1.PID：每个进程的ID；
	2.USER：该进程所属的用户；
	3.PR：Priority的间歇，与Priority有关，也是越小则越早被执行；
	4.NI：Nice的简写，与Priority有关，也是越小则越早被执行；
	5.%CPU：CPU的使用效率；
	6.%MEM：内存的使用效率；
	7.TIME+：CPU使用时间的累加
top默认使用CPU使用率（%CPU）作为排序的依据。如果想要使用内存使用率排序，则可以按下【M】，若要恢复则按下【P】即可。
```

###### pstree

```
pstree [-A|U] [-up]
选项与参数：
-A：各进程树之间的连接以ASCII字符来连接；
-U：各进程树之间的链接以Unicode的字符来连接，在某些终端界面下可能会有错误。
-P：并同时列出每个进程的PID；
-u：并同时列出每个进程的所属账号名称
所有的进程都是依附在systemd这个进程下面的。这个进程的PID是一号，因为它是由Linux内核所主动调用的第一个进程，所以PID就是一号了。
```

##### 任务管理

- 进程是如何互相管理的？是通过给予该进程一个信号（signal）去告知该进程你想要让它做什么。kill -l

  | 代号 | 名称    | 内容                                                         |
  | ---- | ------- | ------------------------------------------------------------ |
  | 1    | SIGHUP  | 启动被终止的进程，可让该PID重新读取自己的配置文件，类似重新启动。 |
  | 2    | SIGINT  | 相当于用键盘输入ctrl+c来终端一个进程的运行                   |
  | 9    | SIGKILL | 代表强制终端一个进程的执行，如果该进程执行到一半，那么尚未完成的部分可能会有【半成品】产生，类似vim会有.filename.swp保留下来 |
  | 15   | SIGTERM | 以正常的方式结束进程来终止该进程。                           |
  | 19   | SIGSTOP | 相当于用键盘输入ctrl+z来暂停一个进程的运行。                 |

- kill -signal PID

  > kill可以帮我们将这个信号传送给某个任务（%number）或是某个PID（直接输入数字）

- 执行任务管理的操作中，其实每个任务都是目前bash的子进程，即彼此之间是有相关性的，我们无法用任务管理的方式有tty1的环境去管理tty2的bash。

- 可以出现提示字符让你操作的环境称为前台，至于其他任务就可以放入后台去暂停或运行；

- 放入后台的任务想要运行时，它必须不能够与用户进行交互，而且放入后台的任务不可以使用ctrl+c来终止；

###### 要执行bash的任务管理要注意的限制：

- 这些任务所能触发的进程必须来自于你shell的子进程（只管理自己的bash）；
- 前台：可以控制与执行命令的这个环境称为前台的任务；
- 后台：可以自动执行的任务，你无法使用ctrl+c终止它，可使用bg、fg调用该任务；
- 后台中执行的进程不能等待terminal或shell的输入（input）

###### job control的管理

- 直接将命令丢到后台中【执行】的 &	

- 将【目前】的任务丢到后台中【暂停】：[ctrl]-z

- 查看目前的后台任务状态：jobs

  ```shell
  jobs [-lrs]
  选项与参数：
  -l ：除了列出job number与命令串之外，同时列出PID的号码；
  -r ：仅列出正在后台run的任务；
  -s ：仅列出正在后台当中暂停（stop）的任务
  ```

- 将后台任务拿到前台处理：fg(foreground)

  ```
  fg %jobnumber
  fg: 默认取出那个+的任务
  ```

- 让任务在后台下的状态变成运行中：bg

  ```
  bg %jobnumber
  ```

- 管理后台当中的任务：kill

  ```
  kill -signal %jobnumber
  signal ：代表给予后面接的那个任务什么样的指示
  	-l(L的小写)：重新读取一次参数的配置文件（类似reload）；
  	-2：代表由键盘输入ctrl-c同样的操作；
  	-9：立刻强制删除一个任务；
  	-15：以正常的进程方式终止一项任务，与-9是不一样的
  ```

###### 脱机管理问题

> nohup：可以在退机或注销系统后，该能够让任务继续执行
>
> nohup [命令或参数] ：在终端前台中任务
>
> nohup [命令或参数] &：在终端后台中任务

###### 进程的优先级（Priority）与CPU调度

> Linux给予进程一个所谓的【优先级（priority, PRI）】，这个PRI值越低代表越优先的意思。不过这个PRI值是由内核动态调整的，用户无法直接调整PRI值。如果要调整进程的优先级，就要通过nice（NI）值。
>
> - nice值可调整的范围-20 ~ 19；
> - root可随意调整自己或他人进程的nice值，且范围为-20 ~ 19；
> - 一般用户仅可调整自己进程的nice值，且范围仅为0-19（避免一般用户抢占系统资源）；
> - 一般用户仅可将nice值越调越高

- 如何调整该进程的nice值？

  - 一开始执行进程就立即给予一个特定的nice值：用nice命令；

    ```
    nice [-n 数字] command
    -n:后面接一个数值，数值的范围-20 - 19；
    ```

  - 调整某个已经存在的PID的nice值：用renice命令；

    ```
    renice [number] PID
    ```

###### 查看系统资源信息

- free:查看内存使用情况

  ```
  # 显示目前系统的内存容量
  free -m
  ```

- uname:查看系统与内核相关信息

- uptime:查看系统启动时间与任务负载

- netstat:追踪网络或socket文件

- dmesg:分析内核产生的信息

- vmstat:检测系统资源变化

##### 认识服务系统

> 服务（service）：常驻内存中的进程且可以提供一些系统或网络功能，那就是服务；
>
> daemon：系统为了某些功能必须要提供一些服务（不论是系统本身还是网络方面），这些服务就称为service：但是service的提供总是需要程序的运行，所以完成这个service的程序称为daemon。

##### 网络服务

> 基本上，会产生一个网络监听端口（port）的进程，就可以称为网络服务。
>
> 查看网络端口：netstat -tlunp

### 内容二：

---

@[toc]
##### 用户及用户组管理

> 用户管理：chmod/useradd/userdel/passwd/id user/su user/whoami/exit/logout
>
> 用户组管理：groupadd/groupdel/chgrd
>
> 相关配置文件：/etc/passwd	/etc/shadow	/etc/group

##### 文件管理

> 文件权限和属性存放在inode中，实际数据存放在数据区块中。
>
> 文件目录切换：cd ~/-/../
>
> 查看文件目录：ls/pwd/tree/file
>
> 文件管理：mkdir/rmdir/touch/cp/rm/mv
>
> 文件查找：which/whereis/locate/find
>
> 文件内容查看：cat/nl/more/less/head/tail/od
>
> 文件默认权限：umask
>
> 文件隐藏属性：chattr (+-=/a/i)、lsattr
>
> 文件特殊权限：SUID/SGID/SBIT 分别对应4/2/1(例：chmod 7755 demo.py)

##### 磁盘管理

> 超级区块：记录整个文件系统的整体信息，包括inode与数据区块的总量、使用量、剩余量等。
>
> inode：记录文件的权限和属性，同时记录文件数据所在的区块号码；
>
> 数据区块：实际记录文件的内容；
>
> df:disk free
>
> du:disk use
>
> free:查看内存使用情况
>
> lsblk（list block device）: 列出系统上的所有磁盘列表；
>
> 硬链接：相当于windows系统中的快捷方式，文件内容由inode的记录来指向，磁盘的空间和inode的数据都不改变
>
> ln [-sf] 源文件 目标文件：有-s是符号链接，没有则为硬链接

##### linux主要目录划分

> /etc  /var  /home  /root  /lib  /opt  /bin  /sbin  /usr  /dev  /sys  /mnt  /boot  /dedia  /run  /tmp

##### 定时任务调度

> 仅执行一次的计划任务 - at
>
> 循环任务：crontab（分时日月周命令）
>
> crontab -e	systemctl restart crond

##### 网络管理

> ifconfig/ping

##### 进程管理：ps aux    top/pstree

> 进程：执行一个程序或触发一个事件并获得一个PID
>
> 操作系统用过PID来判断进程是否具有执行权限。
>
> /bin/bash是一个程序，当被触发产生一个PID，之后后这个进程衍生出来的其他进程在一般状态下，也会沿用这个进程的相关权限
>
> 在linux下面执行一个命令时，系统会将相关的权限、属性、进程代码与数据等均加载到内存，并给予这些进程一个进程标识符（PID），最终该命令可以执行的任务则与这个PID的权限有关。这就是linux的多人多任务的基础。

###### 父子进程

- 某个进程的父进程通过PPID来判断
- linux的程序调用通常称为 **fork-and-exec** 的流程，进程都会借由父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec的方式来执行实际要执行的进程，最终就称为一个子进程。
- 服务：常驻在内存中的进程
- 僵尸进程：该进程本应该执行完毕了，但该进程的父进程却无法完整地将该进程结束掉，导致该进程一直存在内存中。由系统进程systemd来管理，systemd是系统的第一个进程，是所有进程的父进程。

###### 进程优先级（nice值）

- nice [-n 数字] command

##### 任务管理

- 后台执行：&
- 到后台暂停：ctrl + z
- jobs/fg %jobnumber/bg %jobnumber
- kill -signal PID/%jobnumber

##### 服务管理（systemctl/service）

> 服务/守护进程：在后台运行的进程，监听某个端口等待请求
>
> systemctl [start|stop|restart|status]/enable/disable 服务名

##### 网络管理(netstat)

> netstat -anp/-tunlp/ | grep xxx

##### linux软件包管理器：RPM/YUM/APT

- rpm：用于互联网下载包的打包与安装工具
- yum：是CentOS中的一个**shell前端软件包管理器**，基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包
- apt：Ubuntu中的软件包管理工具

##### 日志管理：/var/log

> 日志管理服务：rsyslogd