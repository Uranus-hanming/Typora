[toc]
##### 贪心算法（greedy algorithm）

> 用贪心算法解决问题的思路，并不总能给出最优解。
>
> 贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型

######  贪心算法解决问题的步骤

- 第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了**限制值**和**期望值**，希望**从中选出几个数据**，在满足限制值的情况下，期望值最大。
- 我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。
- 第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。

##### 贪心算法的应用

###### 1. 分糖果

> 我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m<n），所以糖果只能分配给一部分孩子。
>
> 每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。
>
> 我的问题是，如何分配糖果，能尽可能满足最多数量的孩子？
>
> 我们可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。
>
> 我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。

###### 2. 钱币找零

> 假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？
>
> 在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。

###### 3. 区间覆盖

> 假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？
>
> 这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。
>
> 我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。

###### 4. 贪心算法实现霍夫曼编码

##### 最大子数组和

> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组 **是数组中的一个连续部分。
>
> 解题思路：贪心算法，局部最优：从第一个元素开始向后遍历，当“连续累加和”为负数时，说明前面这些数只能成为后边数的累赘，因此从下一个元素重新开始（即count初始化为0）继续向后累加.
> 这里需要注意的是：遍历每个元素都会让count和res比较取二者最大值作为新的res（遍历完整个序列，就代表找到了全局最优res），操作完这个步骤后再判断是否count需要初始化

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = -float('inf')  # 记录当前最大值
        count = 0
        for ind in range(len(nums)):
            # 记录从count初始化为0后的值累加，直到再次满足count<=0表示本次局部遍历结束
            count += nums[ind]
            # 每个局部中的每次count和res比较都相当于找到了遍历过的序列的全局最优，当遍历完整个序列后就相当于找到了整个序列的全局最优
            if count > res:
                res = count
            # 只要count<=0，就让count初始化为0，从当前开始往后继续相加（每次初始化为0，都相当于一个当前的局部）
            if count <= 0:
                count = 0

        return res
```