[toc]
#### 图

- 顶点：图中的元素

- 边

  > 图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫做边（edge）。

- 度：跟顶点相连接的边的条数

- 有向图：边有方向的图（微博）

  - 顶点的**入度**，表示有多少条边指向这个顶点；入度就表示有多少粉丝
  - 顶点的**出度**，表示有多少条边是以这个顶点为起点指向其他顶点。出度就表示关注了多少人

- 无向图：边没有方向的图（微信）

- 带权图（weighted graph）

  > 在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。

#### 内存中存储图数据结构

##### 邻接矩阵存储方法

> 邻接矩阵的底层依赖一个**二维数组**。对于**无向图**来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于**有向图**来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于**带权图**，数组中就存储相应的权重。
>
> 邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。空间换时间

![请添加图片描述](https://img-blog.csdnimg.cn/406cee68302d4499a8ef8d97d7a79150.webp)


###### 用邻接矩阵（Adjacency Matrix）来表示一个图的缺点：浪费空间

> 对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。
>
> 如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。

###### 优点

> 邻接矩阵的存储方式**简单、直接**，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是**方便计算**。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。

##### 邻接表存储方法（Adjacency List）

> 每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。另外我需要说明一下，图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。
>
> 邻接表存储起来比较节省空间，但是使用起来就比较耗时间。时间换空间
>
> 如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。
>
> 为了提高查找效率，可以将邻接表中的链表改成**平衡二叉查找树**（红黑树），或者其他动态数据结构，如**跳表、散列表**等。除此之外，我们还可以将链表改成有序动态数组，可以通过**二分查找**的方法来快速定位两个顶点之间否是存在边。

![请添加图片描述](https://img-blog.csdnimg.cn/462ff2e19d2f44db868b8d4b786c4357.webp)


##### 广度优先算法Breadth-First-Search（BFS）

> 直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。
>
> 最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，**V 表示顶点的个数，E 表示边的个数**。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的**时间复杂度**也可以简写为 **O(E)**。
>
> 广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以**空间复杂度是 O(V)**。
>
> 广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助**队列**来实现，遍历得到的路径就是，起始顶点到终止顶点的**最短路径**。

##### 深度优先搜索Depth-First-Search（DFS）

> 最直观的例子就是“走迷宫”。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。
>
> 图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。
>
> 深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。
>
> 深度优先搜索用的是**回溯思想**，非常适合用**递归**实现。换种说法，深度优先搜索是借助**栈**来实现的。在执行效率方面，深度优先和广度优先搜索的**时间复杂度都是 O(E)，空间复杂度是 O(V)**。